<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebCam æ°´æœå¿è€… (ä¿®å¤ç‰ˆ)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            user-select: none;
        }
        
        #container {
            position: relative;
            width: 1280px;
            height: 720px;
            background: #000;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
            border-radius: 10px;
            overflow: hidden;
        }

        #input_video {
            display: none;
        }

        #game_canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        #ui_layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .hud {
            color: white;
            font-size: 32px;
            font-weight: bold;
            text-shadow: 2px 2px 4px #000;
            display: flex;
            justify-content: space-between;
            z-index: 5;
        }

        #start_screen, #game_over_screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            pointer-events: auto;
            z-index: 10;
            text-align: center;
        }

        h1 { font-size: 48px; margin-bottom: 20px; color: #ffeb3b; }
        p { font-size: 18px; color: #ccc; margin-bottom: 10px; }

        button {
            padding: 15px 50px;
            font-size: 24px;
            background: #ff5722;
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 30px;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(255, 87, 34, 0.4);
        }

        button:hover { transform: scale(1.05); background: #f4511e; }
        
        button:disabled {
            background-color: #555;
            cursor: not-allowed;
            color: #999;
            transform: none;
            box-shadow: none;
        }

        .hidden { display: none !important; }
        
        #debug_log {
            font-size: 14px;
            color: #aaa;
            margin-top: 20px;
            font-family: monospace;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
    
    <!-- å¼•å…¥ MediaPipe åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

<div id="container">
    <video id="input_video" playsinline></video>
    <canvas id="game_canvas" width="1280" height="720"></canvas>

    <div id="ui_layer">
        <div class="hud">
            <span id="score_display">åˆ†æ•°: 0</span>
            <span id="time_display">æ—¶é—´: 60</span>
        </div>
    </div>

    <!-- å¼€å§‹å±å¹• -->
    <div id="start_screen">
        <h1>ğŸ–ï¸ ä½“æ„Ÿåˆ‡æ°´æœ</h1>
        <div id="status_area">
            <p id="loading">æ­£åœ¨è¿æ¥æœåŠ¡å™¨ä¸‹è½½ AI æ¨¡å‹...</p>
            <div id="debug_log">åˆå§‹åŒ–ä¸­...</div>
        </div>
        <button id="start_btn" disabled>ç­‰å¾…åŠ è½½...</button>
        <p style="margin-top:20px; font-size: 14px; color: #888">
            ç©æ³•ï¼šä¸¾èµ·æ‰‹ï¼Œç”¨é£ŸæŒ‡åœ¨ç©ºä¸­åˆ’åŠ¨æ¥åˆ‡æ°´æœï¼<br>
            è¯·å…è®¸æµè§ˆå™¨è®¿é—®æ‘„åƒå¤´æƒé™ã€‚
        </p>
    </div>

    <!-- ç»“æŸå±å¹• -->
    <div id="game_over_screen" class="hidden">
        <h1>â° æ—¶é—´åˆ°!</h1>
        <h2 id="final_score" style="font-size: 36px; color: #fff;">æœ€ç»ˆå¾—åˆ†: 0</h2>
        <button onclick="location.reload()">å†ç©ä¸€æ¬¡</button>
    </div>
</div>

<script>
    // --- 1. å…¨å±€å˜é‡ä¸è®¾ç½® ---
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('game_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const startBtn = document.getElementById('start_btn');
    const loadingText = document.getElementById('loading');
    const debugLog = document.getElementById('debug_log');
    const startScreen = document.getElementById('start_screen');
    const gameOverScreen = document.getElementById('game_over_screen');
    const scoreDisplay = document.getElementById('score_display');
    const timeDisplay = document.getElementById('time_display');
    const finalScoreDisplay = document.getElementById('final_score');

    let gameState = 'MENU'; 
    let score = 0;
    let timeLeft = 60;
    let timerInterval = null;
    let fruits = [];
    let particles = [];
    let handPosition = { x: -100, y: -100 };
    let trail = [];

    const FRUIT_TYPES = ['ğŸ', 'ğŸŒ', 'ğŸ‰', 'ğŸ‡', 'ğŸŠ', 'ğŸ'];
    const GRAVITY = 0.25;

    // å·¥å…·å‡½æ•°ï¼šæ›´æ–°æ—¥å¿—
    function log(msg) {
        console.log(msg);
        debugLog.innerText = msg;
    }

    // é”™è¯¯å¤„ç†
    function handleError(error) {
        console.error(error);
        loadingText.innerHTML = `<span style="color:#ff5252">âŒ é”™è¯¯: ${error.message || error}</span>`;
        debugLog.innerText = "è¯·æ£€æŸ¥ï¼š1.æ‘„åƒå¤´æƒé™æ˜¯å¦å…è®¸ï¼Ÿ 2.ç½‘ç»œæ˜¯å¦é€šç•…ï¼Ÿ";
        startBtn.innerText = "åŠ è½½å¤±è´¥";
    }

    // --- 2. æ ¸å¿ƒåˆå§‹åŒ– ---
    async function init() {
        try {
            if (typeof Hands === 'undefined') {
                throw new Error("MediaPipe åº“ä¸‹è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥ã€‚");
            }

            log("æ­£åœ¨é…ç½® AI æ¨¡å‹...");
            
            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onResults);

            log("æ­£åœ¨è¯·æ±‚æ‘„åƒå¤´æƒé™...");

            const camera = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 1280,
                height: 720
            });

            await camera.start();
            log("æ‘„åƒå¤´å·²å¯åŠ¨ï¼ç­‰å¾…ç”»é¢ç¨³å®š...");
            
            // ç»‘å®šäº‹ä»¶ï¼šå½“è§†é¢‘çœŸçš„å¼€å§‹æ’­æ”¾æ•°æ®æ—¶
            videoElement.addEventListener('loadeddata', () => {
                log("ç³»ç»Ÿå°±ç»ªï¼");
                loadingText.style.display = 'none';
                debugLog.style.display = 'none';
                startBtn.disabled = false;
                startBtn.textContent = "å¼€å§‹æ¸¸æˆ";
                startBtn.onclick = startGame;
            });

        } catch (e) {
            handleError(e);
        }
    }

    // ç«‹å³å¯åŠ¨åˆå§‹åŒ–
    init();


    // --- 3. è§†è§‰å¤„ç†ä¸ä¸»å¾ªç¯ ---
    function onResults(results) {
        // 1. ç»˜åˆ¶æ‘„åƒå¤´èƒŒæ™¯ (é•œåƒç¿»è½¬)
        canvasCtx.save();
        canvasCtx.translate(canvasElement.width, 0);
        canvasCtx.scale(-1, 1);
        canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
        canvasCtx.restore();

        // 2. é»‘è‰²é®ç½©ï¼Œè®©æ°´æœæ›´æ¸…æ™°
        canvasCtx.fillStyle = 'rgba(0, 0, 0, 0.4)';
        canvasCtx.fillRect(0, 0, canvasElement.width, canvasElement.height);

        // 3. æ•æ‰æ‰‹æŒ‡
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            const indexFingerTip = landmarks[8]; // é£ŸæŒ‡æŒ‡å°–
            
            // åæ ‡æ˜ å°„
            const x = (1 - indexFingerTip.x) * canvasElement.width;
            const y = indexFingerTip.y * canvasElement.height;

            handPosition = { x, y };
            trail.push({ x, y, life: 1.0 });
        } else {
            // å¦‚æœæ‰‹ç§»å‡ºå±å¹•ï¼Œå¯ä»¥é€‰æ‹©é‡ç½®ä½ç½®ï¼Œæˆ–è€…ä¿ç•™åœ¨æœ€åä½ç½®
            // handPosition = { x: -500, y: -500 }; 
        }

        // 4. è¿è¡Œæ¸¸æˆé€»è¾‘
        if (gameState === 'PLAYING') {
            updateGame();
        }

        // 5. ç»˜åˆ¶æ¸¸æˆå…ƒç´ 
        drawGame();
    }


    // --- 4. æ¸¸æˆé€»è¾‘ç±»ä¸å‡½æ•° ---

    class Fruit {
        constructor() {
            this.radius = 40;
            this.x = Math.random() * (canvasElement.width - 100) + 50;
            this.y = canvasElement.height + this.radius;
            
            const centerX = canvasElement.width / 2;
            const distToCenter = centerX - this.x;
            
            // æŠ›ç‰©çº¿ç‰©ç†å‚æ•°
            this.vx = distToCenter * 0.012 + (Math.random() - 0.5) * 2;
            this.vy = -(Math.random() * 6 + 13); 
            
            this.emoji = FRUIT_TYPES[Math.floor(Math.random() * FRUIT_TYPES.length)];
            this.rotation = 0;
            this.rotSpeed = (Math.random() - 0.5) * 0.3;
            this.active = true;
        }

        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.vy += GRAVITY;
            this.rotation += this.rotSpeed;

            if (this.y > canvasElement.height + 60) {
                this.active = false;
            }
        }

        draw(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            ctx.font = "70px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(this.emoji, 0, 0);
            ctx.restore();
        }
    }

    class Particle {
        constructor(x, y, color) {
            this.x = x;
            this.y = y;
            this.color = color;
            this.vx = (Math.random() - 0.5) * 12;
            this.vy = (Math.random() - 0.5) * 12;
            this.life = 1.0;
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.vy += 0.2;
            this.life -= 0.03;
        }
        draw(ctx) {
            ctx.globalAlpha = Math.max(0, this.life);
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, Math.random() * 5 + 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1.0;
        }
    }

    function startGame() {
        startScreen.classList.add('hidden');
        gameState = 'PLAYING';
        score = 0;
        timeLeft = 60;
        fruits = [];
        particles = [];
        trail = [];
        scoreDisplay.innerText = "åˆ†æ•°: 0";
        timeDisplay.innerText = "æ—¶é—´: 60";

        if (timerInterval) clearInterval(timerInterval);
        timerInterval = setInterval(() => {
            timeLeft--;
            timeDisplay.innerText = "æ—¶é—´: " + timeLeft;
            if (timeLeft <= 0) {
                endGame();
            }
        }, 1000);
    }

    function endGame() {
        gameState = 'GAMEOVER';
        clearInterval(timerInterval);
        finalScoreDisplay.innerText = "æœ€ç»ˆå¾—åˆ†: " + score;
        gameOverScreen.classList.remove('hidden');
    }

    function updateGame() {
        // ç”Ÿæˆæ°´æœ
        if (Math.random() < 0.04) { 
            fruits.push(new Fruit());
        }

        // æ£€æŸ¥æ°´æœçŠ¶æ€
        for (let i = fruits.length - 1; i >= 0; i--) {
            let f = fruits[i];
            f.update();

            // ç¢°æ’æ£€æµ‹
            let dx = handPosition.x - f.x;
            let dy = handPosition.y - f.y;
            let distance = Math.sqrt(dx*dx + dy*dy);

            if (distance < f.radius + 10) { // +10 å¢åŠ ä¸€ç‚¹åˆ¤å®šèŒƒå›´ï¼Œæ‰‹æ„Ÿæ›´å¥½
                // åˆ‡ä¸­
                score += 10;
                scoreDisplay.innerText = "åˆ†æ•°: " + score;
                createExplosion(f.x, f.y);
                fruits.splice(i, 1);
            } else if (!f.active) {
                fruits.splice(i, 1);
            }
        }

        // æ›´æ–°ç‰¹æ•ˆ
        for (let i = particles.length - 1; i >= 0; i--) {
            particles[i].update();
            if (particles[i].life <= 0) particles.splice(i, 1);
        }

        // æ›´æ–°è½¨è¿¹
        for (let i = trail.length - 1; i >= 0; i--) {
            trail[i].life -= 0.15;
            if (trail[i].life <= 0) trail.splice(i, 1);
        }
    }

    function createExplosion(x, y) {
        // çˆ†å‡ºæœæ±
        for(let i=0; i<12; i++) {
            particles.push(new Particle(x, y, '#ffcc00')); // é»„
            particles.push(new Particle(x, y, '#ff5722')); // çº¢
        }
    }

    function drawGame() {
        // ç»˜åˆ¶æ°´æœ
        fruits.forEach(f => f.draw(canvasCtx));

        // ç»˜åˆ¶ç‰¹æ•ˆç²’å­
        particles.forEach(p => p.draw(canvasCtx));

        // ç»˜åˆ¶åˆ€å…‰
        if (trail.length > 1) {
            canvasCtx.lineCap = 'round';
            canvasCtx.lineJoin = 'round';
            for (let i = 1; i < trail.length; i++) {
                const p1 = trail[i-1];
                const p2 = trail[i];
                if(p2.life <= 0) continue;
                
                canvasCtx.beginPath();
                canvasCtx.lineWidth = p2.life * 15;
                // æ¸å˜è‰²è½¨è¿¹
                canvasCtx.strokeStyle = `rgba(0, 255, 255, ${p2.life})`; 
                canvasCtx.moveTo(p1.x, p1.y);
                canvasCtx.lineTo(p2.x, p2.y);
                canvasCtx.stroke();
            }
        }

        // ç»˜åˆ¶æ‰‹æŒ‡æŒ‡ç¤ºç‚¹
        if (handPosition.x > 0) {
            canvasCtx.beginPath();
            canvasCtx.arc(handPosition.x, handPosition.y, 10, 0, Math.PI*2);
            canvasCtx.fillStyle = "white";
            canvasCtx.fill();
            canvasCtx.strokeStyle = "cyan";
            canvasCtx.lineWidth = 3;
            canvasCtx.stroke();
        }
    }

</script>
</body>
</html>